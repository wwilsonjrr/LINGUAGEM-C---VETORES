/*
31. Faça um programa que leia dois vetores de 10 elementos.
Crie um vetor que seja a união entre os 2 vetores anteriores,
ou seja, que contém os números dos dois vetores.
Não deve conter números repetidos.
*/



#include <stdio.h>
#include <stdlib.h>

int main()
{
    int x[10];       // Declara o vetor X com 5 posições inteiras
    int y[10];       // Declara o vetor Y com 5 posições inteiras
    int k;           // contador de elementos que pertencem a inter []
    int uniao[20];   // Vetor para armazenar a união de X e Y (no máximo 10 elementos)

    // ---------------------------------------------------------------
    // Entrada do vetor X
    // ---------------------------------------------------------------
    printf("Digite 10 elementos para o vetor X:\n");   // Exibe mensagem pedindo os 5 valores de X

    for(int i = 0; i < 10; i++)   // Laço para percorrer as posições 0,1,2,3,4 do vetor X
    {
        scanf("%d", &x[i]);      // Lê um número inteiro digitado pelo usuário e armazena em x[i]
    }

    // ---------------------------------------------------------------
    // Entrada do vetor Y
    // ---------------------------------------------------------------
    printf("\nDigite 10 elementos para o vetor Y:\n"); // Exibe mensagem pedindo os 5 valores de Y

    for(int i = 0; i < 10; i++)   // Laço para percorrer as posições 0,1,2,3,4 do vetor Y
    {
        scanf("%d", &y[i]);      // Lê um número inteiro digitado pelo usuário e armazena em y[i]
    }


    // ---------------------------------------------------------------
    // União entre X e Y (sem repetir elementos)
    // ---------------------------------------------------------------
    printf("\n\nUniao entre X e Y:\n");     // Escreve o título da seção de união

    k = 0;                                  // Reinicia k para usar como índice de preenchimento no vetor uniao[]

    // Primeiro, copia todos os elementos de X para o vetor uniao[]
    for(int i = 0; i < 10; i++)              // Percorre as 5 posições de X
    {
        uniao[k] = x[i];                    // Copia o elemento x[i] para uniao[k]
        k++;                                // Avança k para a próxima posição de uniao[]
    }

    // Depois, adiciona os elementos de Y que não estão em X
    for(int i = 0; i < 10; i++)              // Percorre as 5 posições de Y
    {
        int repetido = 0;                   // Flag que indica se y[i] já existe em X; assume inicialmente que NÃO é repetido

        for(int j = 0; j < 10; j++)          // Percorre as 5 posições de X para comparar com y[i]
        {
            if(y[i] == x[j])                // Se o elemento de Y for igual a algum elemento de X
            {
                repetido = 1;               // Marca que é repetido (já existe em X)
                break;                      // Sai do laço interno, pois não precisa procurar mais
            }
        }

        if(repetido == 0)                   // Se "repetido" continuar 0, significa que y[i] não está em X
        {
            uniao[k] = y[i];                // Inclui y[i] na próxima posição livre de uniao[]
            k++;                            // Avança k para a próxima posição
        }
    }

    for(int i = 0; i < k; i++)              // Percorre todas as posições efetivamente usadas em uniao[]
    {
        printf("%d ", uniao[i]);            // Exibe cada elemento da união (todos de X + os de Y que não estavam em X)
    }



    system("pause");
    return 0;
}
